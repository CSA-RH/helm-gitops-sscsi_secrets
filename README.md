
# Disclaimer
This repo contains an opinionated demo and is NOT an official Red Hat recommendation.

# Automatic Secrets Management with Helm in ArgoCD with Secrets Storage CSI Driver

# Introduction

The objective of this repository is to demonstrate the usage of a Helm chart in ArgoCD and to automate the secrets management in ArgoCD using the Secret Storage CSI Driver (SSCSI) in ARO.

## This repo is using the following tecnologies:
- GitOps/ArgoCD
- Helm
- SSCSI
- Azure KeyVault
- K8s


# Requirements
- Azure KeyVault (azkv) service will be used as the container of the secrets to be mounted in the pods. 
- SSCSI will retrieve the secrets from azkv and mount it in the pods. 
- SSCSI will have to be authenticated against the azkv service, for that a service principal will be used. A SP will have a key that must be protected, therefore this repo uses Sealed Secrets to encript the SP key, which will allow the encrypted key to be added to a Git repository.
- SSCSI by default mounts the retrived azkv secrets retrived as a volume in the pods, nonetheless we have an additional requirement to mount as a K8s secret as well (details bellow). 

# Objects created Manualy


# Objects create by GitOps


# 


# Procedure:

## Overview Steps

1. Clone the Git repository

2. Install GitOps

2. Install SSCSI in ARO

3. Install Sealed Secrets in ARO

4. Exercise: Developer creates a new application in GitOps:
    1. Create the Azure Service Principal (SP)
    2. Encrypt the SP key
    3. The encripted SP Key is uploaded to Git
    4. The developer creates a new Application in GitOps feeding the Git link of the application Helm chart  



## Detailed Procedure

1. Clone the Git repository into your laptop
git clone https://github.com/CSA-RH/helm-gitops-sscsi_secrets.git

2. Install GitOps in your ARO cluster
https://docs.openshift.com/gitops/1.10/installing_gitops/installing-openshift-gitops.html

3. Install SSCSI in ARO
    1. Install procedure (Following links describe how to install the community version.)

        - Red Hat Experts version
            > https://cloud.redhat.com/experts/misc/secrets-store-csi/
            > https://cloud.redhat.com/experts/misc/secrets-store-csi/azure-key-vault/

        - Microsoft version
            > https://learn.microsoft.com/en-us/azure/openshift/howto-use-key-vault-secrets

    2. The following additional steps are required if the SSCSI have to create an K8s secret:
        - add cluster role

            ```$bash
            oc adm policy add-cluster-role-to-user cluster-admin system:serviceaccount:k8s-secrets-store-csi:secrets-store-csi-driver
            ```

        - create custom SCC
            To allow usaging CSI volume and adding the capability "SETGID" (this capability as it is required by the MySQL DDBB Image).

            ```$bash
            oc apply -f clusterprimer/scc.yaml
            ```

       - add role

            ```$bash
            oc apply -f clusterprimer/ClusterRole_scc.yaml 
            ```

4. Install Sealed Secrets in ARO

    Sealed Secrets team has developed a Helm Chart for installing the solution automatically. This automatism is customizable with multiple variables depending on the client requirements.

    It is important to bear in mind that The kubeseal utility uses asymmetric crypto to encrypt secrets that only the controller can decrypt. Please visit the following [link](https://github.com/bitnami-labs/sealed-secrets/blob/main/docs/developer/crypto.md) for more information about security protocols and cryptographic tools used.

    In the following process, a Sealed Secrets controller will be installed using a custom certificate that was generated in the respective namespace previously. This installation model is designed for multi-cluster environments where it is required to use the same certificate in multiple Kubernetes clusters in order to facilitate operations and maintainability.

    - Create Namespace where Sealed Secrets Controller will be deployed

        ```$bash
        oc new-project sealedsecrets
        ```

    - Assign permissions to the default service account in order to be able to deploy the respective controller pod

        ```$bash
        oc adm policy add-scc-to-user anyuid -z sealed-secrets -n sealedsecrets
        ```

    - Generate the respective certificates and create a secret

        ```$bash
        sh scripts/generate-cert.sh
        ```

    - Deploy Sealed Secrets using the respective Helm Chart and the secret generated by the previous script execution

        ```$bash
        helm repo add sealed-secrets https://bitnami-labs.github.io/sealed-secrets
        helm install sealed-secrets -n sealedsecrets --set-string secretName=cert-encryption sealed-secrets/sealed-secrets
        ```

    - Install the command line tool kubeseal
        https://github.com/bitnami-labs/sealed-secrets/releases

        ```$bash
        wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.2/kubeseal-0.24.2-linux-amd64.tar.gz -O kubeseal.tar.gz 
        tar xzf kubeseal.tar.gz
        rm kubeseal.tar.gz
        chmod 755 kubeseal 
        sudo mv kubeseal /usr/local/bin/
        ```

    - To authorize certain calls to the bitnami sealed secrets API Group from the projects. To configure the final namespace to host the respective *SealedSecret* objects and the respective ArgoCD application that handles the creation of the secret:

        ```$bash
        oc apply -f clusterprimer/ClusterRole_namespaceauth.yaml
        ```




    For further details refer to: https://github.com/bitnami-labs/sealed-secrets#installation

# Demo: Developer creates a new application in GitOps:
## Export Enviremont variables to your local laptop

```$bash
export KEYVAULT_RESOURCE_GROUP=lmartinh-rgb6
export KEYVAULT_NAME=lmartinh-vault-1
export KEYVAULT_LOCATION=eastus
export NAMESPACE=petclinic3
export SECRET_NAME=demosecret4
export KEYVAULT_VALUE=petclinic

#Service Principal Key to access the Azure Key Vault 
export AZK_SECRET_NAME=secrets-store-creds
```

## Create the Azure Service Principal (SP)

- Create an Azure Keyvault in your Resource Group that contains ARO

    ```$bash
    az keyvault create -n ${KEYVAULT_NAME} \
          -g ${KEYVAULT_RESOURCE_GROUP} \
          --location ${KEYVAULT_LOCATION}
    ```

- Create a secret in the Keyvault

    ```$bash
    az keyvault secret set \
          --vault-name ${KEYVAULT_NAME} \
          --name ${SECRET_NAME} --value ${KEYVAULT_VALUE}
    ```

- Create a Service Principal to access the keyvault

    ```$bash
    export SERVICE_PRINCIPAL_CLIENT_SECRET="$(az ad sp create-for-rbac \
          --name http://$KEYVAULT_NAME --query 'password' -otsv)"
    ```

    ```$bash
    export SERVICE_PRINCIPAL_CLIENT_ID="$(az ad sp list \
          --display-name http://$KEYVAULT_NAME --query '[0].appId' -otsv)"
    ```

    ```$bash
    echo "SERVICE_PRINCIPAL_CLIENT_SECRET"
    echo $SERVICE_PRINCIPAL_CLIENT_SECRET
    echo "==========="
    echo "SERVICE_PRINCIPAL_CLIENT_ID"
    echo $SERVICE_PRINCIPAL_CLIENT_ID
    ```

- Set an Access Policy for the Service Principal
 
    ```$bash
    az keyvault set-policy -n ${KEYVAULT_NAME} \
          --secret-permissions get \
          --spn ${SERVICE_PRINCIPAL_CLIENT_ID}
    ```

## Create SealedSecret Object
This object will contain the encrypted key used in the service principal to allow authorization to the Azure Key Vault.

- Locally create a secret for Kubernetes to use to access the Key Vault and label it.

```$bash
SERVICE_PRINCIPAL_CLIENT_ID_B64=`echo -n ${SERVICE_PRINCIPAL_CLIENT_ID} | base64`
SERVICE_PRINCIPAL_CLIENT_SECRET_B64=`echo -n ${SERVICE_PRINCIPAL_CLIENT_SECRET} | base64`
```

```$bash
cat <<EOF > secret_azv.yaml
apiVersion: v1
data:
  clientid: ${SERVICE_PRINCIPAL_CLIENT_ID_B64}
  clientsecret: ${SERVICE_PRINCIPAL_CLIENT_SECRET_B64}
kind: Secret
metadata:
  labels:
    secrets-store.csi.k8s.io/used: "true"  
  name: secrets-store-creds
  namespace: ${NAMESPACE}
EOF
```

- locally create the K8s manifest of the Sealed Secret wich embeds the encryption of the secret to have access to the AZV.

```$bash
kubeseal -f secret_azv.yaml -n ${NAMESPACE} --name ${AZK_SECRET_NAME} \
 --controller-namespace=sealedsecrets \
 --controller-name=sealed-secrets \
 --format yaml > helm/pet-clinic/templates/sealed-secret.yaml
```

> **NOTE**
> controller-namespace: define the namespace where the operator is installed, 
> controller-name: is a combination of the SealedSecretController object name and the name of the namespace

- Create namespace and add label to allow GitOps to manage the namespace

```$bash
oc new-project ${NAMESPACE}
```

```$bash
oc label namespace ${NAMESPACE} argocd.argoproj.io/managed-by=openshift-gitops
```

- Give authorization to the namespace to call the bitnami API Group 
> ####Moved to Git#####
#oc adm policy add-role-to-user admin-sealedsecret system:serviceaccount:openshift-gitops:openshift-gitops-argocd-application-controller -n ${NAMESPACE}
```

- Before creating the application it is necessary to make a commit and push to the forked repository. 

```$bash
git add *
git commit -m "argocd sealed secrets"
git push
```

- Deploy the application in GitOps

```$bash
cat <<EOF | oc apply -f -
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: $NAMESPACE
  namespace: openshift-gitops
spec:
  destination:
    namespace: $NAMESPACE
    server: https://kubernetes.default.svc
  project: default
  source:
    helm:
      valueFiles:
      - values.yaml
    path:  helm/pet-clinic/
    repoURL: https://github.com/CSA-RH/helm-gitops-sscsi_secrets.git
    targetRevision: HEAD
EOF
```

# To Delete the Application

```$bash
oc -n openshift-gitops delete Application $NAMESPACE
```

```$bash
oc delete project $NAMESPACE
```
